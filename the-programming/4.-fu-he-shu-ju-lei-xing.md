# 4. 复合数据类型

## 4.1 数组

数组：固定长度，特定类型。

索引下标范围 0 到 len\(array\)-1，len 函数返回元素个数。

```go
var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

// Print the indices and elements.
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}

// Print the elements only.
for _, v := range a {
    fmt.Printf("%d\n", v)
}
```

默认情况下，每个元素被初始化为对应类型的零值。初始化数组：

```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
```

初始化时，长度位置写"..."省略号，表示数组长度由初始化值的个数来决定（长度在编译时确定，并不表示长度是动态的，只是一个语法糖）

```go
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```

数组长度是数组类型的一部分，\[3\]int 和\[4\]int 是不同类型的数组。

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int
```

除了上面的顺序初始化以外，还可以 指定索引和对应值列表的方式对数组初始化。

```go
type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB]) // "3 ￥"
```

用这种形式的初始化，索引的顺序无关紧要，而且没用到的索引可以省略，未指定的元素会用零值初始化。

```go
r := [...]int{99: -1} //长度为100个元素，最后一个元素是-1，其它都是0
```

如果一个数组的元素类型是可以比较的，那么数组的类型也是可以比较的。

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
```

调用函数时，数组作为参数被传递给函数内部参数变量，参数变量接收的是一个副本。不像其它语言会隐式传递数组的引用或指针。这会导致传递大数组时非常低效。可以显式传递数组指针：

```go
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```

## 4.2 Slice

Silce 代表变长的序列。元素都有相同的类型。

Slice 底层引用了一个数组对象。由三部分构成：指针、长度和容量。

* 指针：指向Slice 第一个元素对应的 底层数组元素的地址（Slice第一个元素不一定就是底层数组的第一个元素）。
* 长度：对应Slice 中元素的数目。长度不能超过容量 。len 函数返回长度。
* 容量：一般是从Slice 开始位置到底层数组的结尾位置。cap函数返回容量。

多个Slice之间可以共享底层数据，并且引用的数组部分区间可能重叠。

```go
months := [...]string{1: "January", /* ... */, 12: "December"}
```

![](../.gitbook/assets/image%20%282%29.png)

```go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]
```

`months[4:7]` 创建了新的切片Q2，`months[6:9]` 创建了新的切片 summer，Q2和summer 是两个不同的切片，但是引用了同一个底层数组，并且有重叠部分。

如果切片操作超过 cap\(s\) 的上限将导致一个panic 异常，但是超过len\(s\)不会，只是扩展了slice。

```go
fmt.Println(summer[:20]) // panic: out of range

endlessSummer := summer[:5] // extend a slice (within capacity)
fmt.Println(endlessSummer)  // "[June July August September October]"
```

向函数传递slice 将允许在函数内部修改底层数组的元素。复制一个slice 只是对底层数组创建了一个新的slice 变量

```go
// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

```go
a := [...]int{0, 1, 2, 3, 4, 5}
reverse(a[:])
fmt.Println(a) // "[5 4 3 2 1 0]"
```

 一种将slice元素循环向左旋转n个元素的方法。调用三次reverse 反转函数，第一次反转开头n个元素，第二次反转剩下的，第三次反转所有元素。（向右循环则将第三次调用移动到第一个，即先反转所有元素）

```go
s := []int{0, 1, 2, 3, 4, 5}
// Rotate s left by two positions.
reverse(s[:2])
reverse(s[2:])
reverse(s)
fmt.Println(s) // "[2 3 4 5 0 1]"
```

Slice 之间不能比较，不能使用 == 判断是否含有相同的元素。\[\]byte 类型可以使用bytes.Equal来判读两个序列是否相等，其它类型需要自己实现。

测试一个Slice 是否为空，使用len\(s\) == 0 来判断，而不应该使用 s== nil 来判断。

make 函数用于穿件一个指定元算类型，长度和容量的slice。

```go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```

### 4.2.1 append 函数

内置的append函数用于追加向slice元素。

```go
var runes []rune
for _, r := range "Hello, 世界" {
    runes = append(runes, r)
}
fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"
```

还可以追加多个元素，或者是一个slice

```go
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
```

每次调用append函数，会先检测slice底层数组是否有足够的容量来保存新加的元素。如果有足够空间，直接扩展slice（依然在原有的底层数组之上），并追加新元素。append函数第一个参数与返回值共享**相同**的底层数组。

![](../.gitbook/assets/image%20%283%29.png)

如果没有足够的空间，先分配一个足够大的新的slice，并将原来的slice复制一份到新slice，然后添加新元素。append函数第一个参数与返回值引用**不同**的底层数组。一般情况下，扩展长度是直接将长度翻倍。

![](../.gitbook/assets/image%20%284%29.png)

以下代码演示扩容过程：

```go
func appendInt(x []int, y int) []int {
    var z []int
    zlen := len(x) + 1
    if zlen <= cap(x) {
        // There is room to grow.  Extend the slice.
        z = x[:zlen]
    } else {
        // There is insufficient space.  Allocate a new array.
        // Grow by doubling, for amortized linear complexity.
        zcap := zlen
        if zcap < 2*len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap)
        copy(z, x) // a built-in function; see text
    }
    z[len(x)] = y
    return z
}
```

### 4.2.2 slice 内存技巧



