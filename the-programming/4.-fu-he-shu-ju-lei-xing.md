# 4. 复合数据类型

## 4.1 数组

数组：固定长度，特定类型。

索引下标范围 0 到 len\(array\)-1，len 函数返回元素个数。

```go
var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

// Print the indices and elements.
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}

// Print the elements only.
for _, v := range a {
    fmt.Printf("%d\n", v)
}
```

默认情况下，每个元素被初始化为对应类型的零值。初始化数组：

```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
```

初始化时，长度位置写"..."省略号，表示数组长度由初始化值的个数来决定（长度在编译时确定，并不表示长度是动态的，只是一个语法糖）

```go
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```

数组长度是数组类型的一部分，\[3\]int 和\[4\]int 是不同类型的数组。

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int
```

除了上面的顺序初始化以外，还可以 指定索引和对应值列表的方式对数组初始化。

```go
type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB]) // "3 ￥"
```

用这种形式的初始化，索引的顺序无关紧要，而且没用到的索引可以省略，未指定的元素会用零值初始化。

```go
r := [...]int{99: -1} //长度为100个元素，最后一个元素是-1，其它都是0
```

如果一个数组的元素类型是可以比较的，那么数组的类型也是可以比较的。

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
```

调用函数时，数组作为参数被传递给函数内部参数变量，参数变量接收的是一个副本。不像其它语言会隐式传递数组的引用或指针。这会导致传递大数组时非常低效。可以显式传递数组指针：

```go
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```

## 4.2 Slice

Silce 代表变长的序列。元素都有相同的类型。

Slice 底层引用了一个数组对象。由三部分构成：指针、长度和容量。

* 指针：指向Slice 第一个元素对应的 底层数组元素的地址（Slice第一个元素不一定就是底层数组的第一个元素）。
* 长度：对应Slice 中元素的数目。长度不能超过容量 。len 函数返回长度。
* 容量：一般是从Slice 开始位置到底层数组的结尾位置。cap函数返回容量。

多个Slice之间可以共享底层数据，并且引用的数组部分区间可能重叠。

```go
months := [...]string{1: "January", /* ... */, 12: "December"}
```

![](../.gitbook/assets/image%20%282%29.png)

```go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]
```

`months[4:7]` 创建了新的切片Q2，`months[6:9]` 创建了新的切片 summer，Q2和summer 是两个不同的切片，但是引用了同一个底层数组，并且有重叠部分。

如果切片操作超过 cap\(s\) 的上限将导致一个panic 异常，但是超过len\(s\)不会，只是扩展了slice。

```go
fmt.Println(summer[:20]) // panic: out of range

endlessSummer := summer[:5] // extend a slice (within capacity)
fmt.Println(endlessSummer)  // "[June July August September October]"
```

向函数传递slice 将允许在函数内部修改底层数组的元素。复制一个slice 只是对底层数组创建了一个新的slice 变量

```go
// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

```go
a := [...]int{0, 1, 2, 3, 4, 5}
reverse(a[:])
fmt.Println(a) // "[5 4 3 2 1 0]"
```

 一种将slice元素循环向左旋转n个元素的方法。调用三次reverse 反转函数，第一次反转开头n个元素，第二次反转剩下的，第三次反转所有元素。（向右循环则将第三次调用移动到第一个，即先反转所有元素）

```go
s := []int{0, 1, 2, 3, 4, 5}
// Rotate s left by two positions.
reverse(s[:2])
reverse(s[2:])
reverse(s)
fmt.Println(s) // "[2 3 4 5 0 1]"
```

Slice 之间不能比较，不能使用 == 判断是否含有相同的元素。\[\]byte 类型可以使用bytes.Equal来判读两个序列是否相等，其它类型需要自己实现。

测试一个Slice 是否为空，使用len\(s\) == 0 来判断，而不应该使用 s== nil 来判断。

make 函数用于穿件一个指定元算类型，长度和容量的slice。

```go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```

### 4.2.1 append 函数

内置的append函数用于追加向slice元素。

```go
var runes []rune
for _, r := range "Hello, 世界" {
    runes = append(runes, r)
}
fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"
```

还可以追加多个元素，或者是一个slice

```go
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
```

每次调用append函数，会先检测slice底层数组是否有足够的容量来保存新加的元素。如果有足够空间，直接扩展slice（依然在原有的底层数组之上），并追加新元素。append函数第一个参数与返回值共享**相同**的底层数组。

![](../.gitbook/assets/image%20%283%29.png)

如果没有足够的空间，先分配一个足够大的新的slice，并将原来的slice复制一份到新slice，然后添加新元素。append函数第一个参数与返回值引用**不同**的底层数组。一般情况下，扩展长度是直接将长度翻倍。

![](../.gitbook/assets/image%20%284%29.png)

以下代码演示扩容过程：

```go
func appendInt(x []int, y int) []int {
    var z []int
    zlen := len(x) + 1
    if zlen <= cap(x) {
        // There is room to grow.  Extend the slice.
        z = x[:zlen]
    } else {
        // There is insufficient space.  Allocate a new array.
        // Grow by doubling, for amortized linear complexity.
        zcap := zlen
        if zcap < 2*len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap)
        copy(z, x) // a built-in function; see text
    }
    z[len(x)] = y
    return z
}
```

### 练习

4.7  修改reverse函数用于原地反转UTF-8编码的\[\]byte。是否可以不用分配额外的内存？

```go
package reverse

import (
	"unicode/utf8"
)

func rev(b []byte) {
	size := len(b)
	for i := 0; i < len(b)/2; i++ {
		b[i], b[size-1-i] = b[size-1-i], b[i]
	}
}

// Reverse all the runes, and then the entire slice. The runes' bytes end up in
// the right order.
func revUTF8(b []byte) []byte {
	for i := 0; i < len(b); {
		_, size := utf8.DecodeRune(b[i:])
		rev(b[i : i+size])
		i += size
	}
	rev(b)
	return b
}
```

## 4.3 Map

#### Map 声明

map 是一个哈希表的引用。写为map\[k\]v ，浮点数不适合用作key。使用make函数创建一个map

```go
ages :=make(map[string]int)
```

或 map 字面值语法

```go
ages := map[string]int{
    "alice":   31,
    "charlie": 34,
}
```

delete 函数用于删除元素

```go
delete(ages, "alice") // remove element ages["alice"]
```

map中的元素不能进行取地址操作\(数组和切片可以\)。

```go
_ = &ages["bob"] // compile error: cannot take address of map element
```

#### 遍历

可以使用range 循环遍历所有元素

```go
for name, age := range ages {
    fmt.Printf("%s\t%d\n", name, age)
}
```

map 的迭代顺序是不确定的，使用随机遍历顺序可以强制要求程序不依赖具体的哈希函数实现。如果需要按顺序遍历，可以先对key 的slice进行排序：

```go
import "sort"

var names []string
for name := range ages {
    names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
    fmt.Printf("%s\t%d\n", name, ages[name])
}
```

#### Map 的零值

map 类型的零值是nil, 也就是没有引用任何哈希表。

```go
var ages map[string]int
fmt.Println(ages == nil)    // "true"
fmt.Println(len(ages) == 0) // "true"
```

map 上大部分操作，包括查找、删除、len和range遍历都可以安全的工作在 nil 值得map 上，类似一个空的map。但是**向一个nil 值得map 存入元素会导致panic 异常**：

```go
ages["carol"] = 21 // panic: assignment to entry in nil map
```

向 map 存数据以前必须先 创建 map，例如使用make 函数

如果key 不存在，将返回对应 value 的零值。 当需要知道元素是否真的在map 之中时，例如当value是int类型，需要区分 一个已经存在的0，和元素不存在时返回的0，可以这样测试：

```go
age, ok := ages["bob"]
if !ok { /* "bob" is not a key in this map; age == 0. */ }
```

也可以这样写：

```go
if age, ok := ages["bob"]; !ok { /* ... */ }
```

和slice 一样，map 之间也不能进行相等比较。

```go
func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false
    }
    for k, xv := range x {
        if yv, ok := y[k]; !ok || yv != xv {
            return false
        }
    }
    return true
}
```

 从上面的例子中可以看到如何用!ok 来区分元素不存在，与元素存在但为0的。我们不能简单地用xv != y\[k\]判断，那样会导致在判断下面两个map时产生错误的结果：

```go
// True if equal is written incorrectly.
equal(map[string]int{"A": 0}, map[string]int{"B": 42})
```

#### Set

Go 语言中没有提供set，但是可以用map 实现类似set 的功能。只需要忽略value就可以了。以下 代码通过map的 key不能重复这一特性，确保集合中已经存在的string 不会被重复打印：

```go
func main() {
    seen := make(map[string]bool) // a set of strings
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        line := input.Text()
        if !seen[line] {
            seen[line] = true
            fmt.Println(line)
        }
    }

    if err := input.Err(); err != nil {
        fmt.Fprintf(os.Stderr, "dedup: %v\n", err)
        os.Exit(1)
    }
}
```

Map 的value也可以是一个聚合类型，例如一个map或者 slice。

```go
var graph = make(map[string]map[string]bool)

func addEdge(from, to string) {
    edges := graph[from]
    if edges == nil {
        edges = make(map[string]bool) // 惰性初始化，在每个值首次作为key时，才初始化。
        graph[from] = edges
    }
    edges[to] = true
}

func hasEdge(from, to string) bool {
    return graph[from][to]
}
```



