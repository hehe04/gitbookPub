# 7. 接口

## 7.1 接口约定

接口是合约，是一种抽象的类型

## 7.2 接口类型

```go
package io
type Reader interface {
    Read(p []byte) (n int, err error)
}
type Closer interface {
    Close() error
}
```

新接口类型可以通过组合已有的接口来定义

```go
type ReadWriter interface {
    Reader
    Writer
}
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

## 7.3 实现接口的条件

实现一个接口的所有方法。

空接口（相当于C\#的object 类）

```go
var any interface{}
any = true
any = 12.34
any = "hello"
any = map[string]int{"one": 1}
any = new(bytes.Buffer)
```

可以使用接口实现 类似C\# 类的功能

例如一个程序中可能定义了下列类型

```go
Album
Book
Movie
Magazine
Podcast
TVEpisode
Track
```

抽象这些类型的共有特性，例如标题、发行日期和作者列表。

```go
type Artifact interface {
    Title() string
    Creators() []string
    Created() time.Time
}
```

某一些特性只对某一类产品有效

```go
type Text interface {
    Pages() int
    Words() int
    PageSize() int
}
type Audio interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string // e.g., "MP3", "WAV"
}
type Video interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string // e.g., "MP4", "WMV"
    Resolution() (x, y int)
}
```

## 7.4 flag.Value 接口

读取命令行参数标记

```go
var period = flag.Duration("period", 1*time.Second, "sleep period")

func main() {
    flag.Parse()
    fmt.Printf("Sleeping for %v...", *period)
    time.Sleep(*period)
    fmt.Println()
}
```

输出：默认是1秒，但是可以通过 -period 菏泽个命令行标记来控制。

```text
$ ./sleep -period 50ms
Sleeping for 50ms...
$ ./sleep -period 2m30s
Sleeping for 2m30s...
$ ./sleep -period 1.5h
Sleeping for 1h30m0s...
$ ./sleep -period "1 day"
invalid value "1 day" for flag -period: time: invalid duration 1 day
```

自定义flag 的解析方式

定义一个允许通过华氏度转换为摄氏度的Flag 类型

```go
// *celsiusFlag satisfies the flag.Value interface.
type celsiusFlag struct{ Celsius }

func (f *celsiusFlag) Set(s string) error {
    var unit string
    var value float64
    fmt.Sscanf(s, "%f%s", &value, &unit) // no error check needed
    switch unit {
    case "C", "°C":
        f.Celsius = Celsius(value)
        return nil
    case "F", "°F":
        f.Celsius = FToC(Fahrenheit(value))
        return nil
    }
    return fmt.Errorf("invalid temperature %q", s)
}

// CelsiusFlag defines a Celsius flag with the specified name,
// default value, and usage, and returns the address of the flag variable.
// The flag argument must have a quantity and a unit, e.g., "100C".
func CelsiusFlag(name string, value Celsius, usage string) *Celsius {
    f := celsiusFlag{value}
    flag.CommandLine.Var(&f, name, usage)
    return &f.Celsius
}
```

CelsiusFlag函数返回一个内嵌在 celsiusFlag 类型里面的Celsius 指针给调用者。Celsius 字段会通过Set 方法在标记处理的过程中更新自己的值。

```go
var temp = tempconv.CelsiusFlag("temp", 20.0, "the temperature")

func main() {
    flag.Parse()
    fmt.Println(*temp)
}
```

输出：

```text
$ go build gopl.io/ch7/tempflag
$ ./tempflag
20°C
$ ./tempflag -temp -18C
-18°C
$ ./tempflag -temp 212°F
100°C
$ ./tempflag -temp 273.15K
invalid value "273.15K" for flag -temp: invalid temperature "273.15K"
Usage of ./tempflag:
  -temp value
        the temperature (default 20°C)
$ ./tempflag -help
Usage of ./tempflag:
  -temp value
        the temperature (default 20°C)
```

## 7.5 接口值

接口值由两部分组成，具体类型和值。

对于一个接口的零值就是指 类型和值都是nil，例如，定义一个接口：

```go
var w io.Writer //零值
```

![](../.gitbook/assets/image%20%285%29.png)

变量 w 的具体类型不是指 io.Writer，而是他的具体的动态类型，例如 

```text
var w io.Writer //零值
w = os.Stdout //具体类型是 os.Stdout 的类型os.File
```

w = os.Stdout  将一个具体类型隐式转换为接口类型，等价于显式使用 io.Writer\(os.Stdout\)。此时，这个接口值动态类型被设置为 \*os.File 指针的类型描述符，动态值 被设为 os.Stdout 的拷贝。

![](../.gitbook/assets/image%20%286%29.png)

接口值可以使用==和!=来进行比较。

接口值相等只有两种情况，它们都是nil ，或者它们的动态类型相同，动态值也相等。接口值可以用在map的key 或者作为switch 语句的操作数。

> 注意：如果两个接口值的动态类型不可比较（比如切片），会引起panic 异常。
>
> ```go
> var x interface{} = []int{1, 2, 3}
> fmt.Println(x == x) // panic: comparing uncomparable type []int
> ```

fmt 包的 %T可以打印接口值的动态类型

```go
var w io.Writer
fmt.Printf("%T\n", w) // "<nil>"
w = os.Stdout
fmt.Printf("%T\n", w) // "*os.File"
w = new(bytes.Buffer)
fmt.Printf("%T\n", w) // "*bytes.Buffer"
```

### 7.5.1 警告：一个包含nil 指针的接口不是 nil 接口

一个不包含任何值的 nil 接口值 和一个 包含nil 指针的接口值是不同的。

下面的程序会导致panic 异常，虽然 f 函数内部判断了out !=nil 。

```go
const debug = true

func main() {
    var buf *bytes.Buffer
    if debug {
        buf = new(bytes.Buffer) // enable collection of output
    }
    f(buf) // NOTE: subtly incorrect!
    if debug {
        // ...use buf...
    }
}

// If out is non-nil, output will be written to it.
func f(out io.Writer) {
    // ...do something...
    if out != nil {
        out.Write([]byte("done!\n"))
    }
}
```

main 函数调用f 函数，给f 函数赋予了一个\*bytes.Buffer 的空指针，所以此时out 的动态类型是\*bytes.Buffer，动态值是nil，**但是注意此时 out !=nil** ，意思就是，out变量是一个包含空指针的非空接口。

![](../.gitbook/assets/image%20%287%29.png)

防御性检查 out!=nil 结果是true，会继续执行out.Write\(\[\]byte\("done!\n"\)\) ，意味着Write 方法的Reciever 是nil，因此导致panic 异常。

> 有一些类型，nil 是一个有效地Reciever，不会报panic 异常，例如 `*os.File` 类型，但 \*bytes.Buffer 不在这些种类中。

这个调用实际上违反了\(\*bytes.Buffer\).Write 方法的接收者非空的隐含条件，解决方案是将main 函数中的变量buf的类型改为io.Writer ，因此可以一开始就避免将一个**不完整的值**赋值给这个接口：

```go
var buf io.Writer
if debug {
    buf = new(bytes.Buffer) // enable collection of output
}
f(buf) // OK
```

## 7.6 sort.Inteface 

自定义动态排序，根据用户选择的字段排序

```go
package column

import (
	"fmt"
)

type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("%s: %d", p.Name, p.Age)
}

type columnCmp func(a, b *Person) comparison

type ByColumns struct {
	p          []Person
	columns    []columnCmp
	maxColumns int
}

func NewByColumns(p []Person, maxColumns int) *ByColumns {
	return &ByColumns{p, nil, maxColumns}
}

type comparison int

const (
	lt comparison = iota
	eq
	gt
)

func (c *ByColumns) LessName(a, b *Person) comparison {
	switch {
	case a.Name == b.Name:
		return eq
	case a.Name < b.Name:
		return lt
	default:
		return gt
	}
}

func (c *ByColumns) LessSumOfAgeDigits(a, b *Person) comparison {
	aSum := sumOfDigits(a.Age)
	bSum := sumOfDigits(b.Age)
	switch {
	case aSum == bSum:
		return eq
	case aSum < bSum:
		return lt
	default:
		return gt
	}
}

func sumOfDigits(n int) int {
	sum := 0
	for ; n > 0; n /= 10 {
		sum += n % 10
	}
	return sum
}

func (c *ByColumns) LessAge(a, b *Person) comparison {
	switch {
	case a.Age == b.Age:
		return eq
	case a.Age < b.Age:
		return lt
	default:
		return gt
	}
}

func (c *ByColumns) Len() int      { return len(c.p) }
func (c *ByColumns) Swap(i, j int) { c.p[i], c.p[j] = c.p[j], c.p[i] }

func (c *ByColumns) Less(i, j int) bool {
	for _, f := range c.columns {
		cmp := f(&c.p[i], &c.p[j])
		switch cmp {
		case eq:
			continue
		case lt:
			return true
		case gt:
			return false
		}
	}
	return false
}

func (c *ByColumns) Select(cmp columnCmp) {
	// Prepend the new comparison, as it's the most significant.
	c.columns = append([]columnCmp{cmp}, c.columns...)

	// Don't let the slice of comparisons grow without bound.
	if len(c.columns) > c.maxColumns {
		c.columns = c.columns[:c.maxColumns]
	}
}
```

main.go

```go
package column

import (
	"sort"
	"testing"
)

func Cmp(a, b []Person, t *testing.T) {
	if len(a) != len(b) {
		t.Log("different lengths")
		t.Logf("%s\n%s", a, b)
		t.Fail()
		return
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			t.Logf("different elements, starting at %d", i)
			t.Logf("%s\n%s", a, b)
			t.Fail()
			return
		}
	}
}

func TestByColumns_Age(t *testing.T) {
	people := []Person{
		{"Alice", 20},
		{"Alice", 12},
	}
	c := &ByColumns{people, nil, 2}
	c.Select(c.LessAge)
	sort.Sort(c)
	Cmp(people, []Person{
		{"Alice", 12}, {"Alice", 20},
	}, t)
}

func TestByColumns_Name(t *testing.T) {
	people := []Person{
		{"Bob", 20},
		{"Alice", 20},
	}
	c := &ByColumns{people, nil, 2}
	c.Select(c.LessName)
	sort.Sort(c)
	Cmp(people, []Person{
		{"Alice", 20},
		{"Bob", 20},
	}, t)
}

func TestByColumns_NameAge(t *testing.T) {
	people := []Person{
		{"Alice", 20},
		{"Bob", 12},
		{"Bob", 20},
		{"Alice", 12},
	}
	c := &ByColumns{people, nil, 2}
	c.Select(c.LessAge)
	c.Select(c.LessName)
	sort.Sort(c)
	Cmp(people, []Person{
		{"Alice", 12},
		{"Alice", 20},
		{"Bob", 12},
		{"Bob", 20},
	}, t)
}

func TestByColumns_AgeName(t *testing.T) {
	people := []Person{
		{"Alice", 20},
		{"Bob", 12},
		{"Bob", 20},
		{"Alice", 12},
	}
	c := &ByColumns{people, nil, 2}
	c.Select(c.LessName)
	c.Select(c.LessAge)
	sort.Sort(c)
	Cmp(people, []Person{
		{"Alice", 12},
		{"Bob", 12},
		{"Alice", 20},
		{"Bob", 20},
	}, t)
}

func TestByColumns_SumOfAgeDigitsNameAge(t *testing.T) {
	people := []Person{
		{"Aaron", 9},
		{"Aaron", 81},
		{"Alice", 20},
		{"Bob", 12},
		{"Bob", 20},
		{"Alice", 12},
	}
	maxComparisons := 3
	c := &ByColumns{people, nil, maxComparisons}
	c.Select(c.LessAge)
	c.Select(c.LessAge)
	c.Select(c.LessName)
	c.Select(c.LessSumOfAgeDigits)
	sort.Sort(c)
	Cmp(people, []Person{
		{"Alice", 20},
		{"Bob", 20},
		{"Alice", 12},
		{"Bob", 12},
		{"Aaron", 9},
		{"Aaron", 81},
	}, t)
	if len(c.columns) > maxComparisons {
		t.Errorf("Want %d comparisons, got %d", maxComparisons, len(c.columns))
	}
}
```



