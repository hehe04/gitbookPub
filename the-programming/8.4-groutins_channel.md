# 8.4 Groutins\_channel

## 8.4 Channels

 一个channel是一个通信机制， 每个channel都有一个特殊的类型，也就是channels可发送数据的类型。 channel对应一个make创建的底层数据结构的**引用**。

```go
ch := make(chan int) // ch has type 'chan int'
```

 和其它的引用类型一样，channel的零值也是nil。

 一个channel有发送和接受两个主要操作

```go
ch <- x  // a send statement
x = <-ch // a receive expression in an assignment statement
<-ch     // a receive statement; result is discarded
```

 使用内置的close函数就可以关闭一个channel，关闭以后，针对该channel的任何**发送**操作都将导致panic 异常。

```go
close(ch)
```

试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。

一个参数的make函数创建的是一个无缓存Channel，指定第二个参数（容量），可以创建一个带缓存的channel

```go
ch = make(chan int)    // unbuffered channel
ch = make(chan int, 0) // unbuffered channel
ch = make(chan int, 3) // buffered channel with capacity 3
```

### 8.4.1. 不带缓存的Channels

 一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到接收者接收。相反，如果是接收者先接收，将导致接收者阻塞直到发送者在相同channel上发送数据。

 通过一个无缓存Channels发送数据时，接收者收到数据 发生在唤醒发送者goroutine之前，就是说，接收者先接受，然后才会唤醒发送者的 goroutine。

> _happens before_，这是Go语言并发内存模型的一个关键术语！ x事件和y事件并发，这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序

### 8.4.2. 串联的Channels（Pipeline）

 Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入

![](../.gitbook/assets/image%20%283%29.png)

```go
func main() {
    naturals := make(chan int)
    squares := make(chan int)

    // Counter
    go func() {
        for x := 0; ; x++ {
            naturals <- x
        }
    }()

    // Squarer
    go func() {
        for {
            x := <-naturals
            squares <- x * x
        }
    }()

    // Printer (in main goroutine)
    for {
        fmt.Println(<-squares)
    }
}
```

可以通过关闭channel 来通知接收者该channel 不会再发送数据。

```go
// Squarer
go func() {
    for {
        x, ok := <-naturals
        if !ok {
            break // channel was closed and drained
        }
        squares <- x * x
    }
    close(squares)
}()
```

当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。 接收操作的第二个返回值ok 是一个bool值， ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。

 range循环可直接在channels上面迭代， 它依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环。

```go
func main() {
    naturals := make(chan int)
    squares := make(chan int)

    // Counter
    go func() {
        for x := 0; x < 100; x++ {
            naturals <- x
        }
        close(naturals)
    }()

    // Squarer
    go func() {
        for x := range naturals {
            squares <- x * x
        }
        close(squares)
    }()

    // Printer (in main goroutine)
    for x := range squares {
        fmt.Println(x)
    }
}
```

并不需要关闭每一个channel， 不管一个channel是否被关闭，当它没有被引用时将会被GC回收。

### 8.4.3. 单方向的Channel

 类型`chan<- int`表示一个只发送int的channel，只能发送不能接收。相反，类型`<-chan int`表示一个只接收int的channel，只能接收不能发送，这种限制将在编译期检测。 对一个只接收的channel调用close将是一个编译错误。

```go
func counter(out chan<- int) {
    for x := 0; x < 100; x++ {
        out <- x
    }
    close(out)
}

func squarer(out chan<- int, in <-chan int) {
    for v := range in {
        out <- v * v
    }
    close(out)
}

func printer(in <-chan int) {
    for v := range in {
        fmt.Println(v)
    }
}

func main() {
    naturals := make(chan int)
    squares := make(chan int)
    go counter(naturals)
    go squarer(squares, naturals)
    printer(squares)
}
```

 任何双向channel向单向channel变量的赋值操作都将导致该隐式转换，但是单向channel不能转换为双向。

### 8.4.4. 带缓存的Channels

带缓存的channel 内部有一个队列。队列的容量通过make 函数的第二个参数指定。

```go
ch = make(chan string, 3)
```

![](../.gitbook/assets/image%20%289%29.png)

向缓存channel 发送数据就是向队列尾部插入，接收channel 就是从队列头部删除（FIFO）。如果内部缓存队列满了，插入操作才会阻塞，直到有一个goroutine 执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。

上面代码创建的channel，可以无阻塞的情况下连续向其发送3个值。

```go
ch <- "A"
ch <- "B"
ch <- "C"
```

此刻，channel的内部缓存队列将是满的（图8.3），如果有第四个发送操作将发生阻塞。  


![](../.gitbook/assets/image%20%281%29.png)

 内置的cap函数获取channel 内部缓存的容量

```go
fmt.Println(cap(ch)) // "3"
```

len 函数返回内部缓存有效元素的个数

```go
fmt.Println(len(ch)) // "2"
```

> 不要将有缓存的channel 当作一个队列来用，如果没有其它goroutine 在该channel接收，将导致发送者甚至是整个程序阻塞。 简单的队列，使用slice就可以了

下面的程序会并发的向一个channel 发送数据， 最后接收者只接收第一个收到的响应，也就是最快响应的那一个。 因此mirroredQuery 函数可能在另外两个响应慢的goroutine 响应之前就返回了结果。

```go
func mirroredQuery() string {
    responses := make(chan string, 3)
    go func() { responses <- request("asia.gopl.io") }()
    go func() { responses <- request("europe.gopl.io") }()
    go func() { responses <- request("americas.gopl.io") }()
    return <-responses // return the quickest response
}

func request(hostname string) (response string) { /* ... */ }
```

 如果我们使用了**无缓存的channel**，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，泄漏的goroutines 不会被自动回收.



