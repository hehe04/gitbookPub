# 9. 基于共享变量的并发

## 9.1 竞争条件

一个函数在并发情况下可以正确工作，那么这个函数就是并发安全的。

对于某个类型来说，如果其所有可访问的方法和操作都是并发安全的话，那么该类型就是并发安全的。

包级别的导出函数一般情况下都是并发安全的。修改包级别的变量，必须使用互斥条件。

竞争条件是指程序在多个goroutine 交叉执行操作时，没有给出正确结果。

有三种方式避免数据竞争：

1. 不要写变量
2. 避免从多个goroutine 访问变量
3. 互斥

第一种情况：不要写变量

Icon 方法会判断map是否存在相应的key，不存在才会填充。但是如果Icon 函数被并发调用，这个map 就会存在数据竞争。

```go
var icons = make(map[string]image.Image)
func loadIcon(name string) image.Image

// NOTE: not concurrency-safe!
func Icon(name string) image.Image {
    icon, ok := icons[name]
    if !ok {
        icon = loadIcon(name)
        icons[name] = icon
    }
    return icon
}
```

如果在创建goroutine 之前的初始化阶段就初始化map 的所有值，并且再也不去修改它们，那么任意数量的goroutine 并发访问Icon 都是安全的。

```go
var icons = map[string]image.Image{
    "spades.png":   loadIcon("spades.png"),
    "hearts.png":   loadIcon("hearts.png"),
    "diamonds.png": loadIcon("diamonds.png"),
    "clubs.png":    loadIcon("clubs.png"),
}

// Concurrency-safe.
func Icon(name string) image.Image { return icons[name] }
```

但是，如果update 操作是必须的，这种方式就不适用。

第二种方式：避免多个goroutine 访问变量。下面的程序将balance 变量限制在了monitor goroutine 中\(teller\)

```go
// Package bank provides a concurrency-safe bank with one account.
package bank

var deposits = make(chan int) // send amount to deposit
var balances = make(chan int) // receive balance

func Deposit(amount int) { deposits <- amount }
func Balance() int       { return <-balances }

func teller() {
    var balance int // balance is confined to teller goroutine
    for {
        select {
        case amount := <-deposits:
            balance += amount
        case balances <- balance:
        }
    }
}

func init() {
    go teller() // start the monitor goroutine
}
```

即使一个变量无法在其整个生命周期内被绑定到一个独立goroutine，也可以使用串行绑定。例如在一条流水线上的goroutine 之间共享变量。（参考第八章串联的channel）

```go
type Cake struct{ state string }

func baker(cooked chan<- *Cake) {
    for {
        cake := new(Cake)
        cake.state = "cooked"
        cooked <- cake // baker never touches this cake again
    }
}

func icer(iced chan<- *Cake, cooked <-chan *Cake) {
    for cake := range cooked {
        cake.state = "iced"
        iced <- cake // icer never touches this cake again
    }
}
```

第三种方式：互斥

允许很多goroutine 去访问变量，但是在同一时刻最多只有一个goroutine在访问。详细见下一节。

## 9.2 sync.Mutex 互斥锁



